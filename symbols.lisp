#|
 This file is a part of Staple
 (c) 2014 TymoonNET/NexT http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.tymoonnext.staple)

(defclass symb-object ()
  ((symbol :initarg :symbol :initform (error "SYMBOL required") :accessor symb-symbol)))
(defclass symb-type (symb-object) ())
(defclass symb-variable (symb-object) ())
(defclass symb-function (symb-object) ())
(defclass symb-macro (symb-function) ())
(defclass symb-generic (symb-function) ())
(defclass symb-method (symb-function)
  ((method :initarg :method :initform (error "METHOD required") :accessor symb-method)))
(defclass symb-class (symb-type) ())
(defclass symb-special (symb-variable) ())
(defclass symb-constant (symb-variable) ())

(defmethod print-object ((symb symb-object) stream)
  (print-unreadable-object (symb stream :type T)
    (format stream "~a" (symb-symbol symb)))
  symb)

(defmethod print-object ((symb symb-method) stream)
  (print-unreadable-object (symb stream :type T)
    (format stream "~a ~{~s ~}~s"
            (symb-symbol symb)
            (method-qualifiers (symb-method symb))
            (symb-arguments symb)))
  symb)

(defgeneric symb-name (symb-object)
  (:documentation "")
  (:method ((symb symb-object))
    (symbol-name (symb-symbol symb))))

(defgeneric symb-package (symb-object)
  (:documentation "")
  (:method ((symb symb-object))
    (symbol-package (symb-symbol symb))))

(defgeneric symb-type (symb-object)
  (:documentation "")
  (:method ((symb symb-object))
    (subseq (string-upcase (class-name (class-of symb))) 5)))

(defgeneric symb-scope (symb-object)
  (:documentation "")
  (:method ((symb symb-object))
    (let ((symbol (symb-symbol symb)))
      (nth-value 1 (find-symbol (symbol-name symbol) (symbol-package symbol))))))

(defgeneric symb-qualifiers (symb-object)
  (:documentation "")
  (:method ((symb symb-method))
    (method-qualifiers (symb-method symb)))
  (:method ((symb symb-object))
    NIL))

(defgeneric symb-arguments (symb-object)
  (:documentation "")
  (:method ((symb symb-object))
    NIL)
  (:method ((symb symb-function))
    #+:sbcl (sb-introspect:function-lambda-list (symb-symbol symb))
    #+:allegro (excl:arglist (symb-symbol symb)))
  (:method ((symb symb-method))
    (loop with args = (call-next-method)
          for specializer in (method-specializers (symb-method symb))
          for i from 0
          do (setf (nth i args)
                   (list (nth i args) (etypecase specializer
                                        (eql-specializer `(eql ,(eql-specializer-object specializer)))
                                        (class (class-name specializer)))))
          finally (return args))))

(defgeneric symb-documentation (symb-object)
  (:documentation "")
  (:method ((symb symb-function))
    (documentation (symb-symbol symb) 'function))
  (:method ((symb symb-method))
    (documentation (symb-method symb) T))
  (:method ((symb symb-variable))
    (documentation (symb-symbol symb) 'variable))
  (:method ((symb symb-type))
    (documentation (symb-symbol symb) 'type)))

(defgeneric symb-is (symb-object mask)
  (:documentation "")
  (:method (symb mask) NIL)
  (:method ((symb symb-object) (mask (eql :inherited)))
    (eql (symb-scope symb) :inherited))
  (:method ((symb symb-object) (mask (eql :internal)))
    (eql (symb-scope symb) :internal))
  (:method ((symb symb-object) (mask (eql :external)))
    (eql (symb-scope symb) :external))
  (:method ((symb symb-type) (mask (eql :type))) T)
  (:method ((symb symb-variable) (mask (eql :variable))) T)
  (:method ((symb symb-function) (mask (eql :function))) T)
  (:method ((symb symb-macro) (mask (eql :macro))) T)
  (:method ((symb symb-generic) (mask (eql :generic))) T)
  (:method ((symb symb-method) (mask (eql :method))) T)
  (:method ((symb symb-class) (mask (eql :class))) T)
  (:method ((symb symb-special) (mask (eql :special))) T)
  (:method ((symb symb-constant) (mask (eql :constant))) T))

(defgeneric symb< (a b)
  (:documentation "")
  (:method ((a symb-method) (b symb-generic))
    (if (eql (symb-symbol a) (symb-symbol b))
        T
        (call-next-method)))
  (:method ((a symb-generic) (b symb-method))
    (if (eql (symb-symbol a) (symb-symbol b))
        NIL
        (call-next-method)))
  (:method ((a symb-object) (b symb-object))
    (string< (symb-symbol a) (symb-symbol b))))

(defun symbol-function-p (symbol)
  (and (fboundp symbol)
       (or (listp symbol)
           (not (macro-function symbol)))
       (not (typep (fdefinition symbol) 'standard-generic-function))))

(defun symbol-macro-p (symbol)
  (and (fboundp symbol)
       (macro-function symbol)))

(defun symbol-generic-p (symbol)
  (and (fboundp symbol)
       (typep (fdefinition symbol) 'standard-generic-function)))

(defun symbol-constant-p (symbol)
  #+:lispworks (sys:symbol-constant-p symbol)
  #-:lispworks (constantp symbol))

(defun symbol-special-p (symbol)
  (and (not (symbol-constant-p symbol))
       #+:lispworks (sys:declared-special-p symbol)
       #+:sbcl (eql :special (sb-int:info :variable :kind symbol))
       #+:allegro (eq (sys:variable-information symbol) :special)))

(defun symbol-class-p (symbol)
  (if (find-class symbol nil) T NIL))

(defun package-symbols (package)
  "Gets all symbols within a package."
  (let ((lst ())
        (package (find-package package)))
    (do-symbols (s package lst)
      (when (eq (symbol-package s) package)
        (push s lst)))))

(defun symbol-objects (&rest symbols)
  (let ((objs ()))
    (dolist (symbol symbols objs)
      (when (symbol-function-p symbol)
        (push (make-instance 'symb-function :symbol symbol) objs))
      (when (symbol-macro-p symbol)
        (push (make-instance 'symb-macro :symbol symbol) objs))
      (when (symbol-generic-p symbol)
        (push (make-instance 'symb-generic :symbol symbol) objs)
        (dolist (method (generic-function-methods (symbol-function symbol)))
          (push (make-instance 'symb-method :symbol symbol :method method) objs)))
      (when (symbol-special-p symbol)
        (push (make-instance 'symb-special :symbol symbol) objs))
      (when (symbol-constant-p symbol)
        (push (make-instance 'symb-constant :symbol symbol) objs))
      (when (symbol-class-p symbol)
        (push (make-instance 'symb-class :symbol symbol) objs)))))

(defun package-symbol-objects (package)
  (apply #'symbol-objects (package-symbols package)))
